package main

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/signal"
	"sort"
	"strconv"
	"strings"
	"sync/atomic"
	"syscall"
	"time"

	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
)

// Schema IDs - these would be registered in Schema Registry
const (
	KeySchemaID   = 1
	ValueSchemaID = 2
)

// Message structures
type ValueData struct {
	User  string `json:"user"`
	Car   string `json:"car"`
	Color string `json:"color"`
}

type KafkaMessage struct {
	Key   string    `json:"key"`
	Value ValueData `json:"value"`
}

// Confluent Wire Format message
type ConfluentMessage struct {
	MagicByte byte
	SchemaID  int32
	Data      []byte
}

type MinioConfig struct {
	Endpoint        string
	AccessKeyID     string
	SecretAccessKey string
	UseSSL          bool
	BucketName      string
}

type MinioClient struct {
	client *minio.Client
	config MinioConfig
}

func NewMinioClient(cfg MinioConfig) (*MinioClient, error) {
	minioClient, err := minio.New(cfg.Endpoint, &minio.Options{
		Creds:  credentials.NewStaticV4(cfg.AccessKeyID, cfg.SecretAccessKey, ""),
		Secure: cfg.UseSSL,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create MinIO client: %w", err)
	}

	return &MinioClient{
		client: minioClient,
		config: cfg,
	}, nil
}

func (m *MinioClient) EnsureBucketExists(ctx context.Context) error {
	exists, err := m.client.BucketExists(ctx, m.config.BucketName)
	if err != nil {
		return fmt.Errorf("failed to check if bucket exists: %w", err)
	}

	if !exists {
		err = m.client.MakeBucket(ctx, m.config.BucketName, minio.MakeBucketOptions{})
		if err != nil {
			return fmt.Errorf("failed to create bucket: %w", err)
		}
		log.Printf("Bucket '%s' created successfully", m.config.BucketName)
	} else {
		log.Printf("Bucket '%s' already exists", m.config.BucketName)
	}

	return nil
}

func (m *MinioClient) GetLastObjectNumber(ctx context.Context) (int, error) {
	objectCh := m.client.ListObjects(ctx, m.config.BucketName, minio.ListObjectsOptions{
		Recursive: true,
	})

	var objectNames []string
	for object := range objectCh {
		if object.Err != nil {
			return 0, fmt.Errorf("error listing objects: %w", object.Err)
		}
		objectNames = append(objectNames, object.Key)
	}

	if len(objectNames) == 0 {
		return 0, nil
	}

	sort.Slice(objectNames, func(i, j int) bool {
		numI := extractNumber(objectNames[i])
		numJ := extractNumber(objectNames[j])
		return numI < numJ
	})

	lastObject := objectNames[len(objectNames)-1]
	lastNumber := extractNumber(lastObject)

	return lastNumber, nil
}

func extractNumber(objectName string) int {
	objectName = strings.TrimSuffix(objectName, ".json")
	objectName = strings.TrimSuffix(objectName, ".bin")

	var numberStr string
	for i := len(objectName) - 1; i >= 0; i-- {
		if objectName[i] >= '0' && objectName[i] <= '9' {
			numberStr = string(objectName[i]) + numberStr
		} else {
			break
		}
	}

	if numberStr == "" {
		return 0
	}

	num, err := strconv.Atoi(numberStr)
	if err != nil {
		return 0
	}

	return num
}

// encodeConfluentFormat encodes data in Confluent Wire Format
func encodeConfluentFormat(schemaID int32, data interface{}) ([]byte, error) {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal JSON: %w", err)
	}

	var buf bytes.Buffer
	// Write magic byte
	buf.WriteByte(0)
	// Write schema ID (big-endian)
	binary.Write(&buf, binary.BigEndian, schemaID)
	// Write JSON data
	buf.Write(jsonData)

	return buf.Bytes(), nil
}

func (m *MinioClient) UploadConfluentObject(ctx context.Context, objectName string, keyData, valueData interface{}) error {
	// Encode key in Confluent format
	keyBytes, err := encodeConfluentFormat(KeySchemaID, keyData)
	if err != nil {
		return fmt.Errorf("failed to encode key: %w", err)
	}

	// Encode value in Confluent format
	valueBytes, err := encodeConfluentFormat(ValueSchemaID, valueData)
	if err != nil {
		return fmt.Errorf("failed to encode value: %w", err)
	}

	// Create a combined message structure
	message := map[string]interface{}{
		"key":   keyBytes,
		"value": valueBytes,
	}

	jsonData, err := json.Marshal(message)
	if err != nil {
		return fmt.Errorf("failed to marshal message: %w", err)
	}

	_, err = m.client.PutObject(ctx, m.config.BucketName, objectName,
		bytes.NewReader(jsonData), int64(len(jsonData)), minio.PutObjectOptions{
			ContentType: "application/json",
		})

	if err != nil {
		return fmt.Errorf("failed to upload object: %w", err)
	}

	return nil
}

func (m *MinioClient) UploadJSONObject(ctx context.Context, objectName string, data *KafkaMessage) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal JSON: %w", err)
	}

	_, err = m.client.PutObject(ctx, m.config.BucketName, objectName,
		bytes.NewReader(jsonData), int64(len(jsonData)), minio.PutObjectOptions{
			ContentType: "application/json",
		})

	if err != nil {
		return fmt.Errorf("failed to upload object: %w", err)
	}

	return nil
}

func generateRandomData(r *rand.Rand) *KafkaMessage {
	IDs := []string{"1", "2", "3", "4"}
	names := []string{"John", "Mike", "Dwight", "Pam", "Kevin"}
	cars := []string{"Kia", "Ford", "BMW"}
	colors := []string{"Red", "Black", "White", "Blue", "Green", "Gray"}

	randomID := IDs[r.Intn(len(IDs))]
	randomName := names[r.Intn(len(names))]
	randomCar := cars[r.Intn(len(cars))]
	randomColor := colors[r.Intn(len(colors))]

	return &KafkaMessage{
		Key: fmt.Sprintf("key-%s", randomID),
		Value: ValueData{
			User:  randomName,
			Car:   randomCar,
			Color: randomColor,
		},
	}
}

func main() {
	config := MinioConfig{
		Endpoint:        "minio.kind.cluster",
		AccessKeyID:     "minio",
		SecretAccessKey: "minio123",
		UseSSL:          false,
		BucketName:      "texts",
	}

	minioClient, err := NewMinioClient(config)
	if err != nil {
		log.Fatal("Error creating MinIO client:", err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	err = minioClient.EnsureBucketExists(ctx)
	if err != nil {
		log.Fatal("Error ensuring bucket exists:", err)
	}

	lastNumber, err := minioClient.GetLastObjectNumber(ctx)
	if err != nil {
		log.Fatal("Error getting last object number:", err)
	}

	log.Printf("Starting from object number: %d", lastNumber+1)
	log.Println("Generating Confluent format objects infinitely... Press Ctrl+C to stop")

	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	signalCh := make(chan os.Signal, 1)
	signal.Notify(signalCh, os.Interrupt, syscall.SIGTERM)

	var uploadedCount int64
	done := make(chan struct{})

	go func() {
		defer close(done)

		currentNumber := lastNumber + 1

		for {
			select {
			case <-ctx.Done():
				return
			default:
				objectName := fmt.Sprintf("kafka/%d.json", currentNumber)

				data := generateRandomData(r)

				// Upload in regular JSON format (you can switch to UploadConfluentObject for wire format)
				err = minioClient.UploadConfluentObject(ctx, objectName, data.Key, data.Value)
				if err != nil {
					log.Printf("Error uploading object %s: %v", objectName, err)
				} else {
					atomic.AddInt64(&uploadedCount, 1)
					if atomic.LoadInt64(&uploadedCount)%10 == 0 {
						log.Printf("Uploaded %d objects so far... Current: %s - Key: %s, User: %s, Car: %s, Color: %s",
							atomic.LoadInt64(&uploadedCount), objectName, data.Key, data.Value.User, data.Value.Car, data.Value.Color)
					}
				}

				currentNumber++
				time.Sleep(2000 * time.Millisecond)
			}
		}
	}()

	<-signalCh
	log.Println("\nReceived interrupt signal. Shutting down gracefully...")
	cancel()
	<-done

	log.Printf("Program stopped. Total objects uploaded in this session: %d", atomic.LoadInt64(&uploadedCount))
}
